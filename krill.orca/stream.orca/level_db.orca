
using krill;
using krill.stream;
using storage.leveldb;

def handle;

def init_db()
{
	..handle = leveldb.open('stream.db');
}

def xadd(key, id, row, maxlen, about)
{
	db_key = '%s_%.6f' % (key, stream._id_to_ts(id));
	db_row = '';
	for k, v in row {
		if v.TYPE == type.string {
			v.replace(',', '.');
		}
	
		db_row += '%s:%s,' % (k, v);
	}

	..handle.put(db_key, db_row);
	return id;
}

def xlen(key)
{
	return 0;
}

def xrange(key, start, end, count, fields)
{
	start_key = '%s_%.6f' % (key, stream._id_to_ts(start));
	s_it = ..handle.lower_bound(start_key);

	end_key = '%s_%.6f' % (key, stream._id_to_ts(end));
	e_it = ..handle.upper_bound(end_key);

	result = [];

	while s_it != e_it {
		v_map = {,};
		v_string = s_it.value();
		toks = v_string.split(',');
		for tok in toks {
			toks_kv = tok.split(':');
			if toks_kv.size() == 2 {
				v_map[toks_kv[0]] = toks_kv[1];
			}
		}

		entry = (s_it.key().split('_')[1].float(), v_map);	
		result.push_back(stream._entry_to_list(entry));
		if count > 0 && result.size() >= count {
			break;
		}

		if s_it == ..handle.last() {
			break;
		}

		s_it.next();
	}

	return result;
}

def xrevrange(key, end, start, count, fields)
{
	start_key = '%s_%.6f' % (key, stream._id_to_ts(start));
	s_it = ..handle.lower_bound(start_key);

	end_key = '%s_%.6f' % (key, stream._id_to_ts(end));
	e_it = ..handle.upper_bound(end_key);

	result = [];

	while e_it != s_it {
		if e_it == ..handle.first() {
			break;
		}
		e_it.prev();

		v_map = {,};
		v_string = e_it.value();
		toks = v_string.split(',');
		for tok in toks {
			toks_kv = tok.split(':');
			if toks_kv.size() == 2 {
				v_map[toks_kv[0]] = toks_kv[1];
			}
		}
		entry = (e_it.key().split('_')[1].integer(), v_map);	
		result.push_back(stream._entry_to_list(entry));

		if count > 0 && result.size() >= count {
			break;
		}

	}

	return result;
}

def xdel(key, ...id_list)
{
	count = 0;
	for id in id_list {
		db_key = '%s_%.6f' % (key, stream._id_to_ts(id));
		if ..handle.find(db_key) == ..handle.end() {
			continue;
		}

		count += 1;
		..handle.erase_key(db_key);
	}

	return count;
}

def xread(key_id_map, count, block)
{
	return [];
}

def xtrim(key, count, about)
{
	del_count = ..count - count;
	if del_count <= 0 {
		return 0;
	}

	// TODO: about
	count = 0;
	for i in range(del_count) {
		..handle.first().erase();
		count += 1;
		..count -= 1;
	}
	
	return count;
}

def dump()
{
	print: 'level db dump';
	for k, v in ..handle {
		print: '  %s - %s' % (k, v);
	}
}

